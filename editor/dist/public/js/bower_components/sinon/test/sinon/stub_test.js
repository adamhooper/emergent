/**
 * @author Christian Johansen (christian@cjohansen.no)
 * @license BSD
 *
 * Copyright (c) 2010-2012 Christian Johansen
 */

if(typeof require=="function"&&typeof module=="object")var buster=require("../runner"),sinon=require("../../lib/sinon");buster.testCase("sinon.stub",{"is spy":function(){var e=sinon.stub.create();assert.isFalse(e.called),assert.isFunction(e.calledWith),assert.isFunction(e.calledOn)},"should contain asynchronous versions of callsArg*, and yields* methods":function(){var e=sinon.stub.create(),t=0,n=0;for(var r in e)e.hasOwnProperty(r)&&r.match(/^(callsArg|yields)/)&&(r.match(/Async/)?r.match(/Async/)&&n++:t++);assert.same(t,n,"Stub prototype should contain same amount of synchronous and asynchronous methods")},"should allow overriding async behavior with sync behavior":function(){var e=sinon.stub(),t=sinon.spy();e.callsArgAsync(1),e.callsArg(1),e(1,t),assert(t.called)},returns:{"returns specified value":function(){var e=sinon.stub.create(),t={};e.returns(t),assert.same(e(),t)},"returns should return stub":function(){var e=sinon.stub.create();assert.same(e.returns(""),e)},"returns undefined":function(){var e=sinon.stub.create();refute.defined(e())}},returnsArg:{"returns argument at specified index":function(){var e=sinon.stub.create();e.returnsArg(0);var t={};assert.same(e(t),t)},"returns stub":function(){var e=sinon.stub.create();assert.same(e.returnsArg(0),e)},"throws if no index is specified":function(){var e=sinon.stub.create();assert.exception(function(){e.returnsArg()},"TypeError")},"throws if index is not number":function(){var e=sinon.stub.create();assert.exception(function(){e.returnsArg({})},"TypeError")}},returnsThis:{"stub returns this":function(){var e={};e.stub=sinon.stub.create(),e.stub.returnsThis(),assert.same(e.stub(),e)},"stub returns undefined when detached":{requiresSupportFor:{strictMode:function(){return this}()===undefined},"":function(){var e=sinon.stub.create();e.returnsThis(),assert.same(e(),undefined)}},"stub respects call/apply":function(){var e=sinon.stub.create();e.returnsThis();var t={};assert.same(e.call(t),t),assert.same(e.apply(t),t)},"returns stub":function(){var e=sinon.stub.create();assert.same(e.returnsThis(),e)}},"throws":{"throws specified exception":function(){var e=sinon.stub.create(),t=new Error;e.throws(t);try{e(),fail("Expected stub to throw")}catch(n){assert.same(n,t)}},"returns stub":function(){var e=sinon.stub.create();assert.same(e.throws({}),e)},"sets type of exception to throw":function(){var e=sinon.stub.create(),t="TypeError";e.throws(t),assert.exception(function(){e()},t)},"specifies exception message":function(){var e=sinon.stub.create(),t="Oh no!";e.throws("Error",t);try{e(),buster.assertions.fail("Expected stub to throw")}catch(n){assert.equals(n.message,t)}},"does not specify exception message if not provided":function(){var e=sinon.stub.create();e.throws("Error");try{e(),buster.assertions.fail("Expected stub to throw")}catch(t){assert.equals(t.message,"")}},"throws generic error":function(){var e=sinon.stub.create();e.throws(),assert.exception(function(){e()},"Error")}},callsArg:{setUp:function(){this.stub=sinon.stub.create()},"calls argument at specified index":function(){this.stub.callsArg(2);var e=sinon.stub.create();this.stub(1,2,e),assert(e.called)},"returns stub":function(){assert.isFunction(this.stub.callsArg(2))},"throws if argument at specified index is not callable":function(){this.stub.callsArg(0),assert.exception(function(){this.stub(1)},"TypeError")},"throws if no index is specified":function(){var e=this.stub;assert.exception(function(){e.callsArg()},"TypeError")},"throws if index is not number":function(){var e=this.stub;assert.exception(function(){e.callsArg({})},"TypeError")}},callsArgWith:{setUp:function(){this.stub=sinon.stub.create()},"calls argument at specified index with provided args":function(){var e={};this.stub.callsArgWith(1,e);var t=sinon.stub.create();this.stub(1,t),assert(t.calledWith(e))},"returns function":function(){var e=this.stub.callsArgWith(2,3);assert.isFunction(e)},"calls callback without args":function(){this.stub.callsArgWith(1);var e=sinon.stub.create();this.stub(1,e),assert(e.calledWith())},"calls callback with multiple args":function(){var e={},t=[];this.stub.callsArgWith(1,e,t);var n=sinon.stub.create();this.stub(1,n),assert(n.calledWith(e,t))},"throws if no index is specified":function(){var e=this.stub;assert.exception(function(){e.callsArgWith()},"TypeError")},"throws if index is not number":function(){var e=this.stub;assert.exception(function(){e.callsArgWith({})},"TypeError")}},callsArgOn:{setUp:function(){this.stub=sinon.stub.create(),this.fakeContext={foo:"bar"}},"calls argument at specified index":function(){this.stub.callsArgOn(2,this.fakeContext);var e=sinon.stub.create();this.stub(1,2,e),assert(e.called),assert(e.calledOn(this.fakeContext))},"returns stub":function(){var e=this.stub.callsArgOn(2,this.fakeContext);assert.isFunction(e)},"throws if argument at specified index is not callable":function(){this.stub.callsArgOn(0,this.fakeContext),assert.exception(function(){this.stub(1)},"TypeError")},"throws if no index is specified":function(){var e=this.stub;assert.exception(function(){e.callsArgOn()},"TypeError")},"throws if no context is specified":function(){var e=this.stub;assert.exception(function(){e.callsArgOn(3)},"TypeError")},"throws if index is not number":function(){var e=this.stub;assert.exception(function(){e.callsArgOn(this.fakeContext,2)},"TypeError")},"throws if context is not an object":function(){var e=this.stub;assert.exception(function(){e.callsArgOn(2,2)},"TypeError")}},callsArgOnWith:{setUp:function(){this.stub=sinon.stub.create(),this.fakeContext={foo:"bar"}},"calls argument at specified index with provided args":function(){var e={};this.stub.callsArgOnWith(1,this.fakeContext,e);var t=sinon.stub.create();this.stub(1,t),assert(t.calledWith(e)),assert(t.calledOn(this.fakeContext))},"returns function":function(){var e=this.stub.callsArgOnWith(2,this.fakeContext,3);assert.isFunction(e)},"calls callback without args":function(){this.stub.callsArgOnWith(1,this.fakeContext);var e=sinon.stub.create();this.stub(1,e),assert(e.calledWith()),assert(e.calledOn(this.fakeContext))},"calls callback with multiple args":function(){var e={},t=[];this.stub.callsArgOnWith(1,this.fakeContext,e,t);var n=sinon.stub.create();this.stub(1,n),assert(n.calledWith(e,t)),assert(n.calledOn(this.fakeContext))},"throws if no index is specified":function(){var e=this.stub;assert.exception(function(){e.callsArgOnWith()},"TypeError")},"throws if no context is specified":function(){var e=this.stub;assert.exception(function(){e.callsArgOnWith(3)},"TypeError")},"throws if index is not number":function(){var e=this.stub;assert.exception(function(){e.callsArgOnWith({})},"TypeError")},"throws if context is not an object":function(){var e=this.stub;assert.exception(function(){e.callsArgOnWith(2,2)},"TypeError")}},objectMethod:{setUp:function(){this.method=function(){},this.object={method:this.method},this.wrapMethod=sinon.wrapMethod},tearDown:function(){sinon.wrapMethod=this.wrapMethod},"returns function from wrapMethod":function(){var e=function(){};sinon.wrapMethod=function(){return e};var t=sinon.stub(this.object,"method");assert.same(t,e)},"passes object and method to wrapMethod":function(){var e=function(){},t;sinon.wrapMethod=function(){return t=arguments,e},sinon.stub(this.object,"method"),assert.same(t[0],this.object),assert.same(t[1],"method")},"uses provided function as stub":function(){var e=!1,t=sinon.stub(this.object,"method",function(){e=!0});t(),assert(e)},"wraps provided function":function(){var e=function(){},t=sinon.stub(this.object,"method",e);refute.same(t,e),assert.isFunction(t.restore)},"throws if third argument is provided but not function":function(){var e=this.object;assert.exception(function(){sinon.stub(e,"method",{})},"TypeError")},"stubbed method should be proper stub":function(){var e=sinon.stub(this.object,"method");assert.isFunction(e.returns),assert.isFunction(e.throws)},"custom stubbed method should not be proper stub":function(){var e=sinon.stub(this.object,"method",function(){});refute.defined(e.returns),refute.defined(e.throws)},"stub should be spy":function(){var e=sinon.stub(this.object,"method");this.object.method(),assert(e.called),assert(e.calledOn(this.object))},"custom stubbed method should be spy":function(){var e=sinon.stub(this.object,"method",function(){});this.object.method(),assert(e.called),assert(e.calledOn(this.object))},"stub should affect spy":function(){var e=sinon.stub(this.object,"method");e.throws("TypeError");try{this.object.method()}catch(t){}assert(e.threw("TypeError"))},"returns standalone stub without arguments":function(){var e=sinon.stub();assert.isFunction(e),assert.isFalse(e.called)},"throws if property is not a function":function(){var e={someProp:42};assert.exception(function(){sinon.stub(e,"someProp")}),assert.equals(e.someProp,42)},"successfully stubs falsey properties":function(){var e={0:function(){}};sinon.stub(e,0,function(){return"stubbed value"}),assert.equals(e[0](),"stubbed value")},"does not stub function object":function(){assert.exception(function(){sinon.stub(function(){})})}},everything:{"stubs all methods of object without property":function(){var e={func1:function(){},func2:function(){},func3:function(){}};sinon.stub(e),assert.isFunction(e.func1.restore),assert.isFunction(e.func2.restore),assert.isFunction(e.func3.restore)},"stubs prototype methods":function(){function e(){}e.prototype.func1=function(){};var t=new e;sinon.stub(t),assert.isFunction(t.func1.restore)},"returns object":function(){var e={};assert.same(sinon.stub(e),e)},"only stubs functions":function(){var e={foo:"bar"};sinon.stub(e),assert.equals(e.foo,"bar")}},"function":{"throws if stubbing non-existent property":function(){var e={};assert.exception(function(){sinon.stub(e,"ouch")}),refute.defined(e.ouch)},"has toString method":function(){var e={meth:function(){}};sinon.stub(e,"meth"),assert.equals(e.meth.toString(),"meth")},"toString should say 'stub' when unable to infer name":function(){var e=sinon.stub();assert.equals(e.toString(),"stub")},"toString should prefer property name if possible":function(){var e={};e.meth=sinon.stub(),e.meth(),assert.equals(e.meth.toString(),"meth")}},yields:{"invokes only argument as callback":function(){var e=sinon.stub().yields(),t=sinon.spy();e(t),assert(t.calledOnce),assert.equals(t.args[0].length,0)},"throws understandable error if no callback is passed":function(){var e=sinon.stub().yields();try{throw e(),new Error}catch(t){assert.equals(t.message,"stub expected to yield, but no callback was passed.")}},"includes stub name and actual arguments in error":function(){var e={somethingAwesome:function(){}},t=sinon.stub(e,"somethingAwesome").yields();try{throw t(23,42),new Error}catch(n){assert.equals(n.message,"somethingAwesome expected to yield, but no callback was passed. Received [23, 42]")}},"invokes last argument as callback":function(){var e=sinon.stub().yields(),t=sinon.spy();e(24,{},t),assert(t.calledOnce),assert.equals(t.args[0].length,0)},"invokes first of two callbacks":function(){var e=sinon.stub().yields(),t=sinon.spy(),n=sinon.spy();e(24,{},t,n),assert(t.calledOnce),assert(!n.called)},"invokes callback with arguments":function(){var e={id:42},t=sinon.stub().yields(e,"Crazy"),n=sinon.spy();t(n),assert(n.calledWith(e,"Crazy"))},"throws if callback throws":function(){var e={id:42},t=sinon.stub().yields(e,"Crazy"),n=sinon.stub().throws();assert.exception(function(){t(n)})},"plays nice with throws":function(){var e=sinon.stub().throws().yields(),t=sinon.spy();assert.exception(function(){e(t)}),assert(t.calledOnce)},"plays nice with returns":function(){var e={},t=sinon.stub().returns(e).yields(),n=sinon.spy();assert.same(t(n),e),assert(n.calledOnce)},"plays nice with returnsArg":function(){var e=sinon.stub().returnsArg(0).yields(),t=sinon.spy();assert.same(e(t),t),assert(t.calledOnce)},"plays nice with returnsThis":function(){var e={},t=sinon.stub().returnsThis().yields(),n=sinon.spy();assert.same(t.call(e,n),e),assert(n.calledOnce)}},yieldsOn:{setUp:function(){this.stub=sinon.stub.create(),this.fakeContext={foo:"bar"}},"invokes only argument as callback":function(){var e=sinon.spy();this.stub.yieldsOn(this.fakeContext),this.stub(e),assert(e.calledOnce),assert(e.calledOn(this.fakeContext)),assert.equals(e.args[0].length,0)},"throws if no context is specified":function(){assert.exception(function(){this.stub.yieldsOn()},"TypeError")},"throws understandable error if no callback is passed":function(){this.stub.yieldsOn(this.fakeContext);try{throw this.stub(),new Error}catch(e){assert.equals(e.message,"stub expected to yield, but no callback was passed.")}},"includes stub name and actual arguments in error":function(){var e={somethingAwesome:function(){}},t=sinon.stub(e,"somethingAwesome").yieldsOn(this.fakeContext);try{throw t(23,42),new Error}catch(n){assert.equals(n.message,"somethingAwesome expected to yield, but no callback was passed. Received [23, 42]")}},"invokes last argument as callback":function(){var e=sinon.spy();this.stub.yieldsOn(this.fakeContext),this.stub(24,{},e),assert(e.calledOnce),assert(e.calledOn(this.fakeContext)),assert.equals(e.args[0].length,0)},"invokes first of two callbacks":function(){var e=sinon.spy(),t=sinon.spy();this.stub.yieldsOn(this.fakeContext),this.stub(24,{},e,t),assert(e.calledOnce),assert(e.calledOn(this.fakeContext)),assert(!t.called)},"invokes callback with arguments":function(){var e={id:42},t=sinon.spy();this.stub.yieldsOn(this.fakeContext,e,"Crazy"),this.stub(t),assert(t.calledWith(e,"Crazy")),assert(t.calledOn(this.fakeContext))},"throws if callback throws":function(){var e={id:42},t=sinon.stub().throws();this.stub.yieldsOn(this.fakeContext,e,"Crazy"),assert.exception(function(){this.stub(t)})}},yieldsTo:{"yields to property of object argument":function(){var e=sinon.stub().yieldsTo("success"),t=sinon.spy();e({success:t}),assert(t.calledOnce),assert.equals(t.args[0].length,0)},"throws understandable error if no object with callback is passed":function(){var e=sinon.stub().yieldsTo("success");try{throw e(),new Error}catch(t){assert.equals(t.message,"stub expected to yield to 'success', but no object with such a property was passed.")}},"includes stub name and actual arguments in error":function(){var e={somethingAwesome:function(){}},t=sinon.stub(e,"somethingAwesome").yieldsTo("success");try{throw t(23,42),new Error}catch(n){assert.equals(n.message,"somethingAwesome expected to yield to 'success', but no object with such a property was passed. Received [23, 42]")}},"invokes property on last argument as callback":function(){var e=sinon.stub().yieldsTo("success"),t=sinon.spy();e(24,{},{success:t}),assert(t.calledOnce),assert.equals(t.args[0].length,0)},"invokes first of two possible callbacks":function(){var e=sinon.stub().yieldsTo("error"),t=sinon.spy(),n=sinon.spy();e(24,{},{error:t},{error:n}),assert(t.calledOnce),assert(!n.called)},"invokes callback with arguments":function(){var e={id:42},t=sinon.stub().yieldsTo("success",e,"Crazy"),n=sinon.spy();t({success:n}),assert(n.calledWith(e,"Crazy"))},"throws if callback throws":function(){var e={id:42},t=sinon.stub().yieldsTo("error",e,"Crazy"),n=sinon.stub().throws();assert.exception(function(){t({error:n})})}},yieldsToOn:{setUp:function(){this.stub=sinon.stub.create(),this.fakeContext={foo:"bar"}},"yields to property of object argument":function(){this.stub.yieldsToOn("success",this.fakeContext);var e=sinon.spy();this.stub({success:e}),assert(e.calledOnce),assert(e.calledOn(this.fakeContext)),assert.equals(e.args[0].length,0)},"throws if no context is specified":function(){assert.exception(function(){this.stub.yieldsToOn("success")},"TypeError")},"throws understandable error if no object with callback is passed":function(){this.stub.yieldsToOn("success",this.fakeContext);try{throw this.stub(),new Error}catch(e){assert.equals(e.message,"stub expected to yield to 'success', but no object with such a property was passed.")}},"includes stub name and actual arguments in error":function(){var e={somethingAwesome:function(){}},t=sinon.stub(e,"somethingAwesome").yieldsToOn("success",this.fakeContext);try{throw t(23,42),new Error}catch(n){assert.equals(n.message,"somethingAwesome expected to yield to 'success', but no object with such a property was passed. Received [23, 42]")}},"invokes property on last argument as callback":function(){var e=sinon.spy();this.stub.yieldsToOn("success",this.fakeContext),this.stub(24,{},{success:e}),assert(e.calledOnce),assert(e.calledOn(this.fakeContext)),assert.equals(e.args[0].length,0)},"invokes first of two possible callbacks":function(){var e=sinon.spy(),t=sinon.spy();this.stub.yieldsToOn("error",this.fakeContext),this.stub(24,{},{error:e},{error:t}),assert(e.calledOnce),assert(e.calledOn(this.fakeContext)),assert(!t.called)},"invokes callback with arguments":function(){var e={id:42},t=sinon.spy();this.stub.yieldsToOn("success",this.fakeContext,e,"Crazy"),this.stub({success:t}),assert(t.calledOn(this.fakeContext)),assert(t.calledWith(e,"Crazy"))},"throws if callback throws":function(){var e={id:42},t=sinon.stub().throws();this.stub.yieldsToOn("error",this.fakeContext,e,"Crazy"),assert.exception(function(){this.stub({error:t})})}},withArgs:{"defines withArgs method":function(){var e=sinon.stub();assert.isFunction(e.withArgs)},"creates filtered stub":function(){var e=sinon.stub(),t=e.withArgs(23);refute.same(t,e),assert.isFunction(e.returns),assert.isFunction(t.returns)},"filters return values based on arguments":function(){var e=sinon.stub().returns(23);e.withArgs(42).returns(99),assert.equals(e(),23),assert.equals(e(42),99)},"filters exceptions based on arguments":function(){var e=sinon.stub().returns(23);e.withArgs(42).throws(),refute.exception(e),assert.exception(function(){e(42)})}},callsArgAsync:{setUp:function(){this.stub=sinon.stub.create()},"asynchronously calls argument at specified index":function(e){this.stub.callsArgAsync(2);var t=sinon.spy(e);this.stub(1,2,t),assert(!t.called)}},callsArgWithAsync:{setUp:function(){this.stub=sinon.stub.create()},"asynchronously calls callback at specified index with multiple args":function(e){var t={},n=[];this.stub.callsArgWithAsync(1,t,n);var r=sinon.spy(e(function(){assert(r.calledWith(t,n))}));this.stub(1,r),assert(!r.called)}},callsArgOnAsync:{setUp:function(){this.stub=sinon.stub.create(),this.fakeContext={foo:"bar"}},"asynchronously calls argument at specified index with specified context":function(e){var t=this.fakeContext;this.stub.callsArgOnAsync(2,t);var n=sinon.spy(e(function(){assert(n.calledOn(t))}));this.stub(1,2,n),assert(!n.called)}},callsArgOnWithAsync:{setUp:function(){this.stub=sinon.stub.create(),this.fakeContext={foo:"bar"}},"asynchronously calls argument at specified index with provided context and args":function(e){var t={},n=this.fakeContext;this.stub.callsArgOnWithAsync(1,n,t);var r=sinon.spy(e(function(){assert(r.calledOn(n)),assert(r.calledWith(t))}));this.stub(1,r),assert(!r.called)}},yieldsAsync:{"asynchronously invokes only argument as callback":function(e){var t=sinon.stub().yieldsAsync(),n=sinon.spy(e);t(n),assert(!n.called)}},yieldsOnAsync:{setUp:function(){this.stub=sinon.stub.create(),this.fakeContext={foo:"bar"}},"asynchronously invokes only argument as callback with given context":function(e){var t=this.fakeContext;this.stub.yieldsOnAsync(t);var n=sinon.spy(e(function(){assert(n.calledOnce),assert(n.calledOn(t)),assert.equals(n.args[0].length,0)}));this.stub(n),assert(!n.called)}},yieldsToAsync:{"asynchronously yields to property of object argument":function(e){var t=sinon.stub().yieldsToAsync("success"),n=sinon.spy(e(function(){assert(n.calledOnce),assert.equals(n.args[0].length,0)}));t({success:n}),assert(!n.called)}},yieldsToOnAsync:{setUp:function(){this.stub=sinon.stub.create(),this.fakeContext={foo:"bar"}},"asynchronously yields to property of object argument with given context":function(e){var t=this.fakeContext;this.stub.yieldsToOnAsync("success",t);var n=sinon.spy(e(function(){assert(n.calledOnce),assert(n.calledOn(t)),assert.equals(n.args[0].length,0)}));this.stub({success:n}),assert(!n.called)}},onCall:{"can be used with returns to produce sequence":function(){var e=sinon.stub().returns(3);e.onFirstCall().returns(1).onCall(2).returns(2),assert.same(e(),1),assert.same(e(),3),assert.same(e(),2),assert.same(e(),3)},"can be used with returnsArg to produce sequence":function(){var e=sinon.stub().returns("default");e.onSecondCall().returnsArg(0),assert.same(e(1),"default"),assert.same(e(2),2),assert.same(e(3),"default")},"can be used with returnsThis to produce sequence":function(){var e={};e.stub=sinon.stub().returns("default"),e.stub.onSecondCall().returnsThis(),assert.same(e.stub(),"default"),assert.same(e.stub(),e),assert.same(e.stub(),"default")},"can be used with throwsException to produce sequence":function(){var e=sinon.stub(),t=new Error;e.onSecondCall().throwsException(t),e();try{e(),fail("Expected stub to throw")}catch(n){assert.same(n,t)}},"in combination with withArgs":{"can produce a sequence for a fake":function(){var e=sinon.stub().returns(0);e.withArgs(5).returns(-1).onFirstCall().returns(1).onSecondCall().returns(2),assert.same(e(0),0),assert.same(e(5),1),assert.same(e(0),0),assert.same(e(5),2),assert.same(e(5),-1)},"falls back to stub default behaviour if fake does not have its own default behaviour":function(){var e=sinon.stub().returns(0);e.withArgs(5).onFirstCall().returns(1),assert.same(e(5),1),assert.same(e(5),0)},"falls back to stub behaviour for call if fake does not have its own behaviour for call":function(){var e=sinon.stub().returns(0);e.withArgs(5).onFirstCall().returns(1),e.onSecondCall().returns(2),assert.same(e(5),1),assert.same(e(5),2),assert.same(e(4),0)},"defaults to undefined behaviour once no more calls have been defined":function(){var e=sinon.stub();e.withArgs(5).onFirstCall().returns(1).onSecondCall().returns(2),assert.same(e(5),1),assert.same(e(5),2),refute.defined(e(5))},"does not create undefined behaviour just by calling onCall":function(){var e=sinon.stub().returns(2);e.onFirstCall(),assert.same(e(6),2)},"works with fakes and reset":function(){var e=sinon.stub();e.withArgs(5).onFirstCall().returns(1),e.withArgs(5).onSecondCall().returns(2),assert.same(e(5),1),assert.same(e(5),2),refute.defined(e(5)),e.reset(),assert.same(e(5),1),assert.same(e(5),2),refute.defined(e(5))},"throws an understandable error when trying to use withArgs on behavior":function(){try{sinon.stub().onFirstCall().withArgs(1)}catch(e){assert.match(e.message,/not supported/)}}},"can be used with yields* to produce a sequence":function(){var e={foo:"bar"},t={method1:sinon.spy(),method2:sinon.spy()},n={method2:sinon.spy()},r=sinon.stub().yieldsToOn("method2",e,7,8);r.onFirstCall().yields(1,2).onSecondCall().yieldsOn(e,3,4).onThirdCall().yieldsTo("method1",5,6).onCall(3).yieldsToOn("method2",e,7,8);var i=sinon.spy(),s=sinon.spy();r(i),r(s),r(t),r(t),r(n),assert(i.calledOnce),assert(i.calledWithExactly(1,2)),assert(s.calledOnce),assert(s.calledAfter(i)),assert(s.calledOn(e)),assert(s.calledWithExactly(3,4)),assert(t.method1.calledOnce),assert(t.method1.calledAfter(s)),assert(t.method1.calledWithExactly(5,6)),assert(t.method2.calledOnce),assert(t.method2.calledAfter(t.method1)),assert(t.method2.calledOn(e)),assert(t.method2.calledWithExactly(7,8)),assert(n.method2.calledOnce),assert(n.method2.calledAfter(t.method2)),assert(n.method2.calledOn(e)),assert(n.method2.calledWithExactly(7,8))},"can be used with callsArg* to produce a sequence":function(){var e=sinon.spy(),t=sinon.spy(),n=sinon.spy(),r=sinon.spy(),i=sinon.spy(),s=sinon.spy(),o={foo:"bar"},u=sinon.stub().callsArgOnWith(3,o,"c","d");u.onFirstCall().callsArg(0).onSecondCall().callsArgWith(1,"a","b").onThirdCall().callsArgOn(2,o).onCall(3).callsArgOnWith(3,o,"c","d"),u(e),u(s,t),u(s,s,n),u(s,s,s,r),u(s,s,s,i),assert(e.calledOnce),assert(t.calledOnce),assert(t.calledAfter(e)),assert(t.calledWithExactly("a","b")),assert(n.calledOnce),assert(n.calledAfter(t)),assert(n.calledOn(o)),assert(r.calledOnce),assert(r.calledAfter(n)),assert(r.calledOn(o)),assert(r.calledWithExactly("c","d")),assert(i.calledOnce),assert(i.calledAfter(r)),assert(i.calledOn(o)),assert(i.calledWithExactly("c","d")),assert(s.notCalled)},"can be used with yields* and callsArg* in combination to produce a sequence":function(){var e=sinon.stub().yields(1,2);e.onSecondCall().callsArg(1).onThirdCall().yieldsTo("method").onCall(3).callsArgWith(2,"a","b");var t={method:sinon.spy()},n=sinon.spy(),r=sinon.spy(),i=sinon.spy(),s=sinon.spy();e(n),e(s,r),e(t),e(s,s,i),assert(n.calledOnce),assert(r.calledOnce),assert(r.calledAfter(n)),assert(t.method.calledOnce),assert(t.method.calledAfter(r)),assert(i.calledOnce),assert(i.calledAfter(t.method)),assert(i.calledWithExactly("a","b")),assert(s.notCalled)},"should interact correctly with assertions (GH-231)":function(){var e=sinon.stub(),t=sinon.spy();e.callsArgWith(0,"a"),e(t),assert(t.calledWith("a")),e(t),assert(t.calledWith("a")),e.onThirdCall().callsArgWith(0,"b"),e(t),assert(t.calledWith("b"))}},"reset only resets call history":function(){var e={a:function(){}},t=sinon.spy();sinon.stub(e,"a").callsArg(1),e.a(null,t),e.a.reset(),e.a(null,t),assert(t.calledTwice)},resetBehavior:{"clears yields* and callsArg* sequence":function(){var e=sinon.stub().yields(1);e.onFirstCall().callsArg(1),e.resetBehavior(),e.yields(3);var t=sinon.spy(),n=sinon.spy();e(t,n),assert(n.notCalled),assert(t.calledOnce),assert(t.calledWithExactly(3))},"cleans 'returns' behavior":function(){var e=sinon.stub().returns(1);e.resetBehavior(),refute.defined(e())},"cleans behavior of fakes returned by withArgs":function(){var e=sinon.stub();e.withArgs("lolz").returns(2),e.resetBehavior(),refute.defined(e("lolz"))},"does not clean parents' behavior when called on a fake returned by withArgs":function(){var e=sinon.stub().returns(!1),t=e.withArgs("lolz").returns(!0);t.resetBehavior(),assert.same(e("lolz"),!1),assert.same(e(),!1)},"cleans 'returnsArg' behavior":function(){var e=sinon.stub().returnsArg(0);e.resetBehavior(),refute.defined(e("defined"))},"cleans 'returnsThis' behavior":function(){var e={};e.stub=sinon.stub.create(),e.stub.returnsThis(),e.stub.resetBehavior(),refute.defined(e.stub())},"does not touch properties that are reset by 'reset'":{calledOnce:function(){var e=sinon.stub();e(1),e.resetBehavior(),assert(e.calledOnce)},"called multiple times":function(){var e=sinon.stub();e(1),e(2),e(3),e.resetBehavior(),assert(e.called),assert.equals(e.args.length,3),assert.equals(e.returnValues.length,3),assert.equals(e.exceptions.length,3),assert.equals(e.thisValues.length,3),assert.defined(e.firstCall),assert.defined(e.secondCall),assert.defined(e.thirdCall),assert.defined(e.lastCall)},"call order state":function(){var e=[sinon.stub(),sinon.stub()];e[0](),e[1](),e[0].resetBehavior(),assert(e[0].calledBefore(e[1]))},"fakes returned by withArgs":function(){var e=sinon.stub(),t=e.withArgs("a"),n=e.withArgs("b");e("a"),e("b"),e("c");var r=e.withArgs("c");e.resetBehavior(),assert(t.calledOnce),assert(n.calledOnce),assert(r.calledOnce)}}}});